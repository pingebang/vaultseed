# VaultSeed 当前实现安全风险分析

## 当前实现概述

### 对称密钥"加密"实现（问题所在）
```typescript
// 当前实现 - encryptKeyWithPublicKey
export async function encryptKeyWithPublicKey(
  aesKey: string,
  publicKey: string
): Promise<string> {
  // 注意：这里简化处理，实际应该使用非对称加密
  // 由于浏览器限制，这里只做 base64 编码
  return btoa(aesKey + ':' + publicKey.substring(0, 32));
}

// 当前实现 - decryptKeyWithPrivateKey
export async function decryptKeyWithPrivateKey(
  encryptedKey: string,
  privateKey: string
): Promise<string> {
  // 简化处理
  const decoded = atob(encryptedKey);
  return decoded.split(':')[0];
}
```

## 安全风险分析

### 1. 主要风险：Base64 不是加密

**风险等级**：高危 ⚠️

**问题描述**：
- Base64 是一种编码（encoding），不是加密（encryption）
- 编码只是将二进制数据转换为可打印字符，没有任何保密性
- 任何人都可以轻松解码 base64 数据

**攻击示例**：
```javascript
// 假设后端存储的加密密钥是：
const encryptedKey = "NjQzMjE6MHgyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIz";

// 攻击者可以轻松解码：
const decoded = atob(encryptedKey); // "64321:0x23456789abcdef0123456789abcdef0123"
const aesKey = decoded.split(':')[0]; // "64321" - 这就是 AES 密钥！
```

### 2. 服务器端风险

**风险**：服务器管理员或数据库被攻破时，所有用户数据都会泄露

**具体风险**：
1. **数据库泄露**：攻击者获取数据库后，可以直接解码所有加密密钥
2. **服务器日志**：如果加密密钥在日志中，可以直接被读取
3. **中间人攻击**：如果使用 HTTP，网络流量可以被拦截和解码

**影响范围**：所有用户的加密内容

### 3. 违背端到端加密原则

**设计目标**：端到端加密意味着只有用户能解密自己的数据，服务器不能访问明文

**当前问题**：
- 服务器可以轻松解码 base64 获取 AES 密钥
- 服务器可以使用 AES 密钥解密用户内容
- 实际上不是真正的端到端加密

### 4. 密钥管理风险

**私钥存储**：私钥存储在 localStorage 中
- **风险**：XSS 攻击可以窃取私钥
- **风险**：浏览器扩展可以访问 localStorage
- **风险**：设备丢失或被盗时，私钥可能被获取

### 5. 重放攻击风险

**当前保护**：使用 nonce 机制防止重放攻击
- ✅ 解密时需要签名验证
- ✅ 每次解密后更新 nonce
- ✅ 防止重复使用相同的签名

**剩余风险**：如果攻击者获取了加密密钥，可以绕过签名验证

## 攻击场景模拟

### 场景 1：数据库泄露
1. 攻击者获取数据库备份
2. 找到 `encrypted_contents` 表
3. 对每个记录的 `encrypted_key` 字段进行 base64 解码
4. 获取 AES 密钥，解密所有用户内容

### 场景 2：服务器管理员作恶
1. 服务器管理员有数据库访问权限
2. 管理员可以解码任何用户的加密密钥
3. 管理员可以解密和查看所有用户内容

### 场景 3：网络嗅探（HTTP 环境）
1. 用户创建内容时，加密密钥通过 HTTP 发送
2. 攻击者拦截网络流量
3. 对 base64 编码的密钥进行解码
4. 获取 AES 密钥，解密内容

## 风险等级评估

| 风险类型 | 风险等级 | 影响 | 可能性 |
|---------|---------|------|--------|
| Base64 编码泄露 | 高危 | 所有用户数据泄露 | 高 |
| 服务器端访问 | 高危 | 服务器可读所有数据 | 高 |
| 数据库泄露 | 高危 | 批量数据泄露 | 中 |
| 网络嗅探 | 中危 | 单个会话数据泄露 | 低（如果使用 HTTPS） |
| XSS 攻击 | 中危 | 单个用户数据泄露 | 中 |
| 重放攻击 | 低危 | 已被 nonce 机制防护 | 低 |

## 与真正端到端加密的对比

### 理想方案（真正端到端加密）
```
用户设备：
  明文内容 → AES加密 → 密文
  AES密钥 → 公钥加密 → 加密的密钥
  
服务器：
  只存储：密文 + 加密的密钥
  
解密时：
  加密的密钥 → 私钥解密 → AES密钥
  AES密钥 → 解密密文 → 明文内容
```

**关键点**：服务器从未接触 AES 密钥或明文内容

### 当前方案（伪端到端加密）
```
用户设备：
  明文内容 → AES加密 → 密文
  AES密钥 → base64编码 → "加密的密钥"
  
服务器：
  存储：密文 + base64编码的密钥
  
解密时：
  base64编码的密钥 → base64解码 → AES密钥
  AES密钥 → 解密密文 → 明文内容
```

**关键点**：服务器可以轻松获取 AES 密钥，因此可以解密所有内容

## 建议的修复方案

### 短期修复（最小改动）
使用简单的对称加密保护 AES 密钥：
```typescript
// 使用公钥哈希作为密钥进行 AES 加密
const hash = SHA256(publicKey);
const encryptedAesKey = AES-GCM(aesKey, hash);
```

**优点**：
- 快速实现
- 真正加密，不是编码
- 服务器无法轻易解密

**缺点**：
- 仍然是对称加密，不是真正的非对称加密
- 如果知道公钥，理论上可以暴力破解（但需要大量计算）

### 长期修复（推荐）
使用真正的非对称加密：
1. **Web Crypto API 的 RSA-OAEP**
2. **libsodium 的 crypto_box_seal**
3. **以太坊的 eth-sig-util 加密**

## 结论

**当前实现存在严重安全风险**：
- ❌ Base64 编码不是加密
- ❌ 服务器可以解密所有用户内容
- ❌ 违背端到端加密设计原则
- ❌ 数据库泄露会导致批量数据泄露

**建议立即修复**，至少实现一个简单的对称加密方案来保护 AES 密钥，而不是使用 base64 编码。

**真正的端到端加密要求**：
1. 只有用户能解密自己的数据
2. 服务器不能访问解密密钥
3. 加密算法必须是真正的加密，不是编码
4. 密钥管理必须安全
